# 多线程总纲

[TOC]

## 一  . Synchoized 总结

```java
> synchronized 是一种重量级锁

// 原理
1 Java 对象头 和 Monitor
	|-> 对象头 ：Mark Word（标记字段）、Klass Pointer（类型指针）
		|-> Klass Pointer : 类元数据指针，决定是何数据
		|-> Mark Word : 自身运行时数据 （hashcode,锁状态，偏向，标志位等）
	|-> Monitor : 
		|-> 互斥 ：一个 Monitor 锁在同一时刻只能被一个线程占用
		|-> 
> synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置
            

// 加锁方式 ，当前实例 ，当前class , 自定义object
> synchronized(this)
> synchronized(object)
> synchronized(class) 或者静态代码块
            
> synchronized关键字最主要的三种使用方式：
> 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
	
> 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。
	也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。

> 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！


// 解释
1 synchronized 提供了一种独占式的加锁方式 ，其添加和释放锁的方式由JVM实现


// --> 阻塞
当 synchronized  尝试获取锁的时候，获取不到锁，将会一直阻塞
            
            
>  谈谈 synchronized和ReenTrantLock 的区别
	- 两者都是可重入锁
	- synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API
    - ReenTrantLock 比 synchronized 增加了一些高级功能  
		?- 等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）
```



## 二  . Volatile  总结

```java
> volatile 保证内存的可见性 并且 禁止指令重排
> volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的  
> 保证线程可见性且提供了一定的有序性

> 我们需要区别 volatile 变量和 atomic 变量
	// volatile 并不能很好的保证原子性
volatile 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。
AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 #getAndIncrement() 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。
    
// Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。
    
// volatile 和 synchronized 的区别
1. volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。
3. volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。
4. volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。
5. volatile 标记的变量不会被编译器优化。synchronized标记的变量可以被编译器优化。
另外，会有面试官会问 volatile 能否取代 synchronized 呢？答案肯定是不能，虽然说 volatile 被称之为轻量级锁，但是和 synchronized 是有本质上的区别，原因就是上面的几点落。
    
// 原理
观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令，其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile 的底层就是通过内存屏障来实现的。    
```



## 三  .  线程对象  / 框架

### 3 . 1 Excutor

```
> 根据一组执行策略调用，调度，执行和控制的异步任务的框架
> 不同方法按照我们的需求创建了不同的线程池

// 普通任务线程池
> newFixedThreadPool(int nThreads)
> newCachedThreadPool()
> newSingleThreadExecutor() 

```





## 四   . 线程的状态改变

### 4 . 1 线程等待

```java
// 等待具体时间
> sleep(time) 
    // 该方式不释放锁 ，低优先级有机会执行
    // sleep 后转入 阻塞（blocked）
> wait(time)
> join(time)
> LockSupport.parkNanos()
> LockSupport.parkUnit()
> yield
	// 该方式同样不会释放锁 ，同优先级及高优先级执行
	// 执行后转入ready
	
// 仅 进入等待
> wait()
> join()
> LockSuppot.park()    

```

### 4 . 2 线程通知

```java
// 对于设定具体等待时间的 timeout 后自动转入就绪

// 其他等待
> notify()
> notifyAll()
    
```

### 4 .  3 线程中断

```java
> interrupt() 
    // 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。

> interrupted ()
	// 查询当前线程的中断状态，并且清除原状态。
	
> isInterrupted ()
    // 查询指定线程的中断状态，不会清除原状态+
```

## 五 .  CAS

### 5 . 1 CAS 简介

```JAVA
CAS操作 —— Compare & Set ，或是 Compare & Swap
//先比较 , 再设置

jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。
CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做	

    
// 效率
CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快
    
// 消耗 : cache miss
一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信

// 当存在 cache 和 数据不在一个域中时    
“最好情况”是指对某一个变量执行 CAS 操作的 CPU 正好是最后一个操作该变量的CPU，所以对应的缓存线已经在 CPU 的高速缓存中了    
```



### 5 . 2 缺陷

```java
// CAS 操作有什么缺点

1）ABA 问题
比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。
从 Java5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
2）循环时间长开销大
对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。
3）只能保证一个共享变量的原子操作
当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。

```



## 六  . 线程池

### 线程池的元素

```
> 线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程。任务队列是一个阻塞队列，保存待执行的任务。工作者线程主体就是一个循环，循环从队列中接受任务并执行。
```



### **为什么要用线程池**

```
降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
```

### 常见的线程池

```
ThreadPoolExecutor 基本对象

FixedThreadPool : 可重用固定线程数的线程池
	- ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);
SingleThreadExecutor : 使用单个worker线程的Executor
	- 
CachedThreadPool : 会根据需要创建新线程的线程池
```

### Fork/Join

```
1 >  Fork / Join 的核心是 ForkJoinPool , 用于来管理工作线程 
	: 工作线程一次只能执行一个任务 ，
	: 不会根据任务创建线程，而是将任务存储到工作线程的双端队列中
2 > Fork / join 的思路是分而治之，Fork 递归的将任务分为较小的子任务，Join : 将子任务递归的串联成单个结果

3 > 工作窃取算法 : 空闲的线程试图从繁忙的线程（他们的双端队列）中窃取工作
```

### 线程池的创建

```
通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则
> 通过构造方法实现 
> 通过Executor 框架的工具类Executors来实现
	• FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
	• SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
	• CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
```

### ThreadPoolExecutor

```
ThreadPoolExecutor实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。

> ThreadPoolExecutor
	- AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
	: 此变量 记录了 “线程池中的任务数量”和“线程池的状态”两个信息
	: 高3位表示"线程池状态"，低29位表示"线程池中的任务数量"
	  - RUNNING : 111 : 该线程词能接收新任务 ,且能对新任务进行处理
	  - SHUTDOWN : 000 : 不能接收新任务 ,但是可以对任务进行处理
	  - STOP : 001 : 不添加新任务 , 不对任务进行处理 , 会中断正在执行的任务
	  - TIDYING : 010 : 当所有的任务已终止，ctl记录的"任务数量"为0，线程池会变为TIDYING状态
	  		- 当所有的任务已终止，ctl记录的"任务数量"为0，线程池会变为TIDYING状态
	  - TERMINATED : 011 : 线程池彻底终止的状态
	
----------------------------------------

> ThreadPoolExecutor 的参数
	- corePoolSize : 线程池中核心线程的数量
	- maximumPoolSize : 线程池中允许的最大线程数
	- keepAliveTime : 线程空闲的时间
	- unit : keepAliveTime的单位
	- workQueue : 用来保存等待执行的任务的阻塞队列，等待的任务必须实现Runnable接口
	- threadFactory : 用于设置创建线程的工厂
```



###  线程池的动态调整

```
ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：
• setCorePoolSize：设置核心池大小。
• setMaximumPoolSize：设置线程池最大能创建的线程数目大小。
当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。

```

### **线程池执行任务的过程**

```
刚创建时，里面没有线程调用 execute() 方法，添加任务时：
1. 如果正在运行的线程数量小于核心参数 corePoolSize ，继续创建线程运行这个任务
	• 否则，如果正在运行的线程数量大于或等于 corePoolSize ，将任务加入到阻塞队列中。
	• 否则，如果队列已满，同时正在运行的线程数量小于核心参数 maximumPoolSize ，继续创建线程运行这个任务。
	• 否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize ，根据设置的拒绝策略处理。
2. 完成一个任务，继续取下一个任务处理。
	• 没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。
	• 否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 corePoolSize 。

```



### **线程池中 submit 和 execute 方法有什么区别**

```
两个方法都可以向线程池提交任务。
• #execute(...) 方法，返回类型是 void ，它定义在 Executor 接口中。
#submit(...) 方法，可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。
```

### **如果你提交任务时，线程池队列已满，这时会发生什么** 

```
艿艿：重点在于线程池的队列是有界还是无界的。
• 如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。
如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 。
```



## 七  . 阻塞队列

### 7 . 1 阻塞队列简述

```
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：
	• 在队列为空时，获取元素的线程会等待队列变为非空。
	• 当队列满时，存储元素的线程会等待队列可用。
阻塞队列常用于生产者和消费者的场景：
	• 生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程
	• 阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：
	• 当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。
	• 当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。
	• 正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。
阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：
	• 读取数据的线程不断将数据放入队列。
	• 然后，解析线程不断从队列取数据解析。

• 【最常用】ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
	此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。
• LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
	此队列按照先出先进的原则对元素进行排序
• PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
• DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。
• SynchronousQueue：一个不存储元素的阻塞队列。
	每一个 put 必须等待一个 take 操作，否则不能继续添加元素。并且他支持公平访问队列。
• LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
	相对于其他阻塞队列，多了 tryTransfer 和 transfer 方法。
	• transfer 方法：如果当前有消费者正在等待接收元素（take 或者待时间限制的 poll 方法），transfer 可以把生产者传入的元素立刻传给消费者。如果没有消		费者等待接收元素，则将元素放在队列的 tail 节点，并等到该元素被消费者消费了才返回。
	• tryTransfer 方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回 false 。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。
• LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
	优势在于多线程入队时，减少一半的竞争。


方法处理方式	抛出异常	返回特殊值	一直阻塞	超时退出
插入方法	add(e)	    offer(e)	 put(e)	   offer(e, time, unit)
移除方法	remove()	poll()	     take()	   poll(time, unit)
检查方法	element()	peek()	     不可用	不可用


> ArrayBlockingQueue 与 LinkedBlockingQueue 的区别

```
### 7 . 2 ArrayBlockingQueue

```JAVA
> 一个由数组实现的有界阻塞队列。该队列采用 FIFO 的原则对元素进行排序添加的
> ArrayBlockingQueue 为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了
> ArrayBlockingQueue 支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。

> 构造器 : 
MC- ArrayBlockingQueue(int capacity)
MC- ArrayBlockingQueue(int capacity, boolean fair)

> 抽象类和接口 
I- BlockingQueue<E> : 提供了在多线程环境下的出列、入列操作
	?- 内部使用可重入锁 ReentrantLock + Condition 来完成多线程环境的并发操作
	
> 变量
• items 变量，一个定长数组，维护 ArrayBlockingQueue 的元素。
• takeIndex 变量，int ，为 ArrayBlockingQueue 队首位置。
• putIndex 变量，int ，ArrayBlockingQueue 队尾位置。
• count 变量，元素个数。
• lock 变量，ReentrantLock ，ArrayBlockingQueue 出列入列都必须获取该锁，两个步骤共用一个锁。
• notEmpty 变量，非空，即出列条件。
• notFull 变量，未满，即入列条件。

> 入队
M- add(E e) 方法 : 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true , 满了抛出异常
M- offer(E e) 方法 : 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true  , 满了返回false
M- offer(E e, long timeout, TimeUnit unit) 方法 : 将指定的元素插入此队列的尾部 , 已满在设定时间内等待
M- put(E e) 方法 : 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间
M- enqueue : 
	- 正常添加元素 , 到达队尾的时候重定向到队头 
	- 总数 + 1 
	- 通知阻塞线程

> 出列
M- poll() 方法：获取并移除此队列的头，如果此队列为空，则返回 null 。
M- poll(long timeout, TimeUnit unit) 方法：获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。
M- take() 方法：获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。
M- remove(Object o) 方法：从此队列中移除指定元素的单个实例（如果存在）。
        
> 核心总结 : 
基于 
        
```

### 7 . 3 DelayQueue

```java
支持延时获取元素的无界阻塞队列。里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说只有在延迟期到时才能够从队列中取元素。

// 作用 : 
• 缓存：清掉缓存中超时的缓存数据
• 任务超时处理

// 关键 : 
1. 可重入锁ReentrantLock
2. 用于阻塞和通知的Condition对象
3. 根据Delay时间排序的优先级队列：PriorityQueue
4. 用于优化阻塞通知的线程元素leader
    
// 结构 :     
E- AbstractQueue
I- BlockingQueue
M- offer() : 往PriorityQueue中添加元素
    - 向 PriorityQueue中插入元素
    - 判断当前元素是否为对首元素，如果是的话则设置leader=null , 唤醒所有线程
M- take()    
    - 获取队首 --- q.peek
    IF- 队首为空 , 阻塞 ,等待off 唤醒
    ELSE- 
    	获取队首的超时时间 , 已过期则出对
    - 如果存在其他线程操作 ,阻塞 , 不存在其他线程 , 独占
    - 超时阻塞 --- available.awaitNanos(delay);
    - 唤醒阻塞线程
```



### ArrayBlockingQueue 与 LinkedBlockingQueue 的区别

| **Queue**           | **阻塞与否** | **是否有界** | **线程安全保障** | **适用场景**                   | **注意事项**                                                 |
| ------------------- | ------------ | ------------ | ---------------- | ------------------------------ | ------------------------------------------------------------ |
| ArrayBlockingQueue  | 阻塞         | 有界         | 一把全局锁       | 生产消费模型，平衡两边处理速度 | 用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间） |
| LinkedBlockingQueue | 阻塞         | 可配置       | 存取采用 2  把锁 | 生产消费模型，平衡两边处理速度 | 无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加  JVM 垃圾回收的负担。 |

### **双端队列**

```
而 ArrayDeque、LinkedBlockingDeque 就是双端队列，类名以 Deque 结尾

• 正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。
	• 如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。
在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。
```

### 队列对象

```
> 阻塞队列 : 阻塞队列有普通的先进先出队列，

> 包括基于数组的ArrayBlockingQueue
> 基于链表的LinkedBlockingQueue/LinkedBlockingDeque
> 基于堆的优先级阻塞队列PriorityBlockingQueue
> 可用于定时任务的延时阻塞队列DelayQueue
> 用于特殊场景的阻塞队列SynchronousQueue和LinkedTransferQueue
```



## 八  . 内存模型

### 9 . 1 happens-before 模型

```
> 定义 : 
1. 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果，将对第二个操作可见，而且第一个操作的执行顺序，排在第二个操作之前。
2. 两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这种重排序并不非法。

> happens-before 规则
	• 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作，happens-before 于书写在后面的操作。
	• 锁定规则：一个 unLock 操作，happens-before 于后面对同一个锁的 lock 操作。
	• volatile 变量规则：对一个变量的写操作，happens-before 于后面对这个变量的读操作。
	• 传递规则：如果操作 A happens-before 操作 B，而操作 B happens-before 操作C，则可以得出，操作 A happens-before 操作C
	• 线程启动规则：Thread 对象的 start 方法，happens-before 此线程的每个一个动作。
	• 线程中断规则：对线程 interrupt 方法的调用，happens-before 被中断线程的代码检测到中断事件的发生。
	• 线程终结规则：线程中所有的操作，都 happens-before 线程的终止检测，我们可以通过Thread.join() 方法结束、Thread.isAlive() 的返回值手段，检测到线程已经终止执行。
	• 对象终结规则：一个对象的初始化完成，happens-before 它的 finalize() 方法的开始
	
> 其他规则
1. 将一个元素放入一个线程安全的队列的操作，happens-before 从队列中取出这个元素的操作。
2. 将一个元素放入一个线程安全容器的操作，happens-before 从容器中取出这个元素的操作。
3. 在 CountDownLatch 上的 countDown 操作，happens-before CountDownLatch 上的 await 操作。
4. 释放 Semaphore 上的 release 的操作，happens-before 上的 acquire 操作。
5. Future 表示的任务的所有操作，happens-before Future 上的 get 操作。
6. 向 Executor 提交一个 Runnable 或 Callable 的操作，happens-before 任务开始执行操作。
```

<img src="C:\Users\10169\OneDrive\笔记文档\图片文件\多线程\happens-before.png" alt="happens-before" style="zoom:150%;" />

### 9 . 2  重排序

```
> 为了提高性能，处理器和编译器常常会对指令进行重排序

1. 在单线程环境下，不能改变程序运行的结果。
存在数据依赖关系的情况下，不允许重排序。
```





## 九  . AQS

### 9 . 1  AQS 基础

```
> 一句话概括AQS : 
一个叫 AbstractQueuedSynchronizer 的抽象类 , 包含2个重要概念 : 以Node为节点实现的链表的队列(CHL队列) + STATE标志 , 支持2种锁 : 独占锁和共享锁 , 


> 什么是 AQS
	: java.util.concurrent.locks.AbstractQueuedSynchronizer 抽象类，简称 AQS 
	: 用于构建锁和同步容器的同步器
	: AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。
	: 其他的节点与等待线程关联，每个节点维护一个等待状态 waitStatus
	:  AQS解决了实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列
	
----------------------------------------

> AQS  : status 的意义
	- AQS 使用一个int 的 status 来表示同步状态
		- status > 0 : 获取了锁
		- status = 0 : 释放了锁
		- status < 0 : 
		
> 基本原理
AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。


AQS定义两种资源共享方式
	• Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： 
		○ 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
		○ 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。


> AQS底层使用了模板方法模式
同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：
	1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）
	2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。
这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。
AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。


	• Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
	• CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。
```

<img src="C:\Users\10169\OneDrive\笔记文档\图片文件\多线程\AQS.png" style="zoom: 200%;" />

## 十  . 原子类

### 10 . 1 原子类的简述

```
基本类型
使用原子的方式更新基本类型
	• AtomicInteger：整形原子类
	• AtomicLong：长整型原子类
	• AtomicBoolean ：布尔型原子类
数组类型
使用原子的方式更新数组里的某个元素
	• AtomicIntegerArray：整形数组原子类
	• AtomicLongArray：长整形数组原子类
	• AtomicReferenceArray ：引用类型数组原子类
引用类型
	• AtomicReference：引用类型原子类
	• AtomicStampedRerence：原子更新引用类型里的字段原子类
	• AtomicMarkableReference ：原子更新带有标记位的引用类型
对象的属性修改类型
	• AtomicIntegerFieldUpdater:原子更新整形字段的更新器
	• AtomicLongFieldUpdater：原子更新长整形字段的更新器
AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
```

### 10 . 2  AtomicInteger 类常用方法

```java

public final int get() //获取当前的值java
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
//以原子方式给当前值加1并获取新值
public final int incrementAndGet()
//以原子方式给当前值减1并获取新值
public final int decrementAndGet()
//以原子方式给当前值加delta并获取新值
public final int addAndGet(int delta)
这些方法的实现都依赖另一个public方法：
public final boolean compareAndSet(int expect, int update)

```

### 10 . 3 原子类的原理

```java
> 之所以称为原子变量，是因为其包含一些以原子方式实现组合操作的方法
原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch切换到另一个线程
>  CAS (compare and swap) + volatile 和 native 方法来保证原子操作
    
// 案例 : AtomicInteger
// 它的主要内部成员是：
private volatile int value;
注意，它的声明带有volatile，这是必需的，以保证内存可见性。

// 它的大部分更新方法实现都类似，我们看一个方法incrementAndGet，其代码为：
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}

先获取当前值current，计算期望的值next，然后调用CAS方法进行更新，如果当前值没有变，则更新并返回新值，否则继续循环直到更新成功为止
    
CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。    
    
```



## 十一  . 并发工具

### 11 . 1 并发工具总结

```
> CyclicBarrier 同步辅助类
	- 允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)
	- 让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活
	
----------------------------------------

> CountDownLatch
	- 在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待
	- 用给定的计数 初始化 CountDownLatch。
	- 由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。
	- 之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。
	- 如果需要重置计数，请考虑使用 CyclicBarrier。
	: CountDownLatch是通过一个计数器来实现的，当我们在new 一个CountDownLatch对象的时候需要带入该计数器值，该值就表示了线程的数量。
	: 每当一个线程完成自己的任务后，计数器的值就会减1。当计数器的值变为0时，就表示所有的线程均已经完成了任务

	
----------------------------------------

> Semaphore 
	- 信号量Semaphore是一个控制访问多个共享资源的计数器，和CountDownLatch一样，其本质上是一个“共享锁”。
	- 


	
----------------------------------------


> Exchanger
	- 可以在对中对元素进行配对和交换的线程的同步点
	- 每个线程将条目上的某个方法呈现给 exchange 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象 , Exchanger 可能被视为 SynchronousQueue 的双向形式
```

### 11 . 2 并发工具 : CyclicBarrier

```java
> 它允许一组线程互相等待，直到到达某个公共屏障点 (Common Barrier Point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 Barrier 在释放等待线程后可以重用，所以称它为循环( Cyclic ) 的 屏障( Barrier ) 。

// 内部原理 : 
ReentrantLock 和 Condition

// 构造函数 : 
CyclicBarrier(int parties)：创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。

CyclicBarrier(int parties, Runnable barrierAction) ：创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。

// 使用变量 : 
parties 变量，表示拦截线程的总数量。
count 变量，表示拦截线程的剩余需要数量。
barrierAction 变量，为 CyclicBarrier 接收的 Runnable 命令，用于在线程到达屏障时，优先执行 barrierAction ，用于处理更加复杂的业务场景。
generation 变量，表示 CyclicBarrier 的更新换代    
 
// 常用方法 : 
M- await : 等待状态
M- await(long timeout, TimeUnit unit) : 等待超时
M- dowait(boolean timed, long nanos)    
SC- Generation : 描述了 CyclicBarrier 的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有 parties 个线程全部到达 barrier 时，generation 就会被更新换代。其中 broken 属性，标识该当前 CyclicBarrier 是否已经处于中断状态
M- breakBarrier : 终止所有的线程
M- nextGeneration : 更新换代操作
	- 1. 唤醒所有线程。
	- 2. 重置 count 。
	- 3. 重置 generation 。
M- reset : 重置 barrier 到初始化状态 
M- getNumberWaiting : 获得等待的线程数
M- 判断 CyclicBarrier 是否处于中断
```

![]()

## 十二  . 并发容器

### 12 . 1 ConcurrentHashMap
```java
> 特点 : 高性能的线程安全HashMap
> 

```

## 十三  . 设计模式

```
> 模式 : 针对某个语境下反复出现的问题得解决方案
> 语境 : 问题所处得状况和背景或者说上下文
> 模式语言 : 模式得集合

```

![](C:\Users\10169\OneDrive\笔记文档\图片文件\其他\多线程模式.jpg)

### Single Threaded Execution :  能同时通过一座桥得只有一个人

```
> 语境 : 多个线程共享实例时
> 问题 : 实例状态不可随意改变 ,影响实例安全性
> 解决 : 严格规定实例得不稳定状态得范围 , 施加保护 , 确保临界区只能被一个线程执行 ,保证线程安全
> 实现 : 通过 synchronized 实现临界区
```

### Immutable : 想破坏也破坏不了
```
> 语境 : 虽然多个线程共享了实例 ,但是实例得状态不会改变
> 问题 : 使用 Single Threaded Excution 模式下 ,吞吐量会下降
> 解决方案 : 对于创建后不会变动得对象 ,使用该模式保证类得不可变性可以提高吞吐量 ,
> 实现 : 通过 private 隐藏字段或者 final 保证其不可改变
    
```

### Guarded Suspension : 等我准备好
```
> 语境 : 多个环境共享实例
> 问题 : 多个线程不可以随意得访问实例 , 如果实例没有准备好 , 会影响安全性
> 解决 : 为实例准备守护状态 , 在执行危险处理前 ,检查实例得安全状态 ,不安全情况下使线程等待
> 实现 : while + wait + notify 实现
```

### Balking : 不需要就算了
```
> 语境 : 多个线程共享实例时
> 问题 : 均可访问影响安全性 , 守护等待影响性能
> 解决 : 不通过while处理 ,中断线程立即返回
> 实现 : if + return/throw
>???? 这逻辑有毛用啊
```


### Producer - Consumer  : 我来做 ,你来用 

```
> producer : 生产者 , 生产数据的线程
> consumer : 消费者 , 使用数据的线程

> 要求 : 生产者安全地将数据交给消费者 ,
> 问题 : 业务的处理效率会导致2者之间的处理速度存在差异 ,
	- 添加新角色 ,桥梁角色 , 用于消除多线间处理速度的差异

> Pipe : 当生产者和消费者都只有一个的时候

> 模式解释 :
	1 . 一个地方只能容纳指定数量的物品的桌子,当物品满了的时候 ,只能等移除其他物品才能加入新的物品 , 
	
	
> 解决 : 准备中间角色 Channel , Channel 中持有多个数据 , 在Channel 中进行线程互斥 
    	
```

### Read - Write - Lock : 读写锁 ,可以一起读 ,但是不能写
 ```
 > 语境 : 多个线程共享实例 ,存在可以读取和改变线程状态的情况
 > 问题 : 需要兼顾安全性和吞吐量
 > 解决 : 将读取锁和写入锁进行区分 , Reader - Reader 没有影响 ,Reader-Writer , Writer - writer 互斥
 > 方案 : 
 ```

### Thread-Per-Message : 这项工作就交给你了
```
> 语境 : 当线程调用实例的方法
> 问题 : 实例的处理时间较长 , 线程无法获取程序的控制权
> 解决 : 
> 方案 : 通过匿名内部类启动新线程
```

### Worker Thread  : 持续工作
```
> 问题 : 虽然可以通过启动新线程释放空间 ,但是会造成负荷 ,所以采用工人线程进行循环使用
> 方案 : 线程池

```

### Future 模式 : 先给提货单

```
> 与其一直等待 , 不如先拿一个提货单
	- data.getContent 获取运行结果
		1 如果其他线程完成了运算 ,会立即返回结果
		2 如果其他线程还没有处理请求 ,会继续等待运行结果
		
> future 模式中 ,核心的对象就是 FutureData  和 RealData
	- FutureData 中持有 realData 对象和 isReady 对象
	- 当getContent 时 ,判断 isReady 并且进入等待 , 获取 realData 对象
		: 所以避免因为未 Ready 导致的阻塞过程
		
		
```

### Two-Phase Termination 模式 : 先收拾房间再睡觉

```
> 问题 : 紧急停止的线程会失去安全性
> 解决 : 

```

### Thread-Specific Storage 模式  : 一个

```
为每个线程准备存储空间 ,就算只有一个入口 ,也会在内部为每个线程分配特有的存储空间

> ThreadLocal 类 : 该类即为存储间 , 或者可以以某个角度将其看成集合,ThreadLocal 可以管理多个对象 , 提供了getter 和 setter 方法
    - set : 通过currentThread 获取线程的值作为key,将线程的参数和调用该方法的线程进行对应
    - get : 以 当前线程的值!去获取set 方法关联的对象
    
> ThreadLocal 对象是一个泛型类 , 可以自定义存储的格式    
    
```

## 十四  . Lock

### 14 . 1  ReentranLock

```java
 > Lock 更多的是  Java 锁接口
 // Java锁 ：更多强调的是 synchronized 和 volatile 关键字带来的重量级和轻量级锁
 
 // 原理     
     
     
 // 常用方法
 > void lock()
 > Condition newCondition()
 > boolean tryLock()
 > void unlock()    
     
     
 > 实现接口 ：ReentranLock
     
java.util.concurrent.locks.Lock 接口，比 synchronized 提供更具拓展行的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：
• 可以使锁更公平。
• 可以使线程在等待锁的时候响应中断。
• 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。
• 可以在不同的范围，以不同的顺序获取和释放锁。
     
     
synchronized 和 ReentrantLock 异同
• 相同点
	• 都实现了多线程同步和内存可见性语义。
	• 都是可重入锁。
• 不同点
	• 同步实现机制不同
		○ synchronized 通过 Java 对象头锁标记和 Monitor 对象实现同步。
		○ ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。
*
	• 可见性实现机制不同
		○ synchronized 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。
		○ ReentrantLock 通过 ASQ 的 volatile state 保证包含共享变量的多线程内存可见性。
	• 使用方式不同
		○ synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。
		○ ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 finally 块中释放锁。
	• 功能丰富程度不同
		○ synchronized 不可设置等待时间、不可被中断（interrupted）。
		○ ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能
	• 锁类型不同
		○ synchronized 只支持非公平锁。
		○ ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。
在 synchronized 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 synchronized 。
并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 
            
            
ReadWriteLock 
ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。
ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。
ReadWriteLock 对程序性能的提高主要受制于如下几个因素：
1. 数据被读取的频率与被修改的频率相比较的结果。
2. 读取和写入的时间
3. 有多少线程竞争
4. 是否在多处理机器上运行

> Lock Condition 
在 Java SE 5 后，Java 提供了 Lock 接口，相对于 synchronized 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活 
            
```

![](C:\Users\10169\OneDrive\笔记文档\图片文件\多线程\lock.jpg)



### 14 . 2 Condition 

```
C- Condition : 条件 Condition 接口
C- ConditionObject


> AQS 等待队列与 Condition 队列是两个相互独立的队列
#await() 就是在当前线程持有锁的基础上释放锁资源，并新建 Condition 节点加入到 Condition 的队列尾部，阻塞当前线程 。
#signal() 就是将 Condition 的头节点移动到 AQS 等待节点尾部，让其等待再次获取锁。

> 流程
	1. 将 head 后移
	2. 释放节点 1 的锁并从 AQS 等待队列中移除
	3. 将节点 1 加入到 Condition 的等待队列中
	4. 更新 lastWaiter 为节点 1
	5. 将 firstWaiter后移
	6. 将节点 4 移出 Condition 队列
	7. 将节点 4 加入到 AQS 的等待队列中去
	8. 更新 AQS 的等待队列的 tail
```

<img src="C:\Users\10169\OneDrive\笔记文档\图片文件\多线程\condition.jpg" style="zoom:150%;" />

## 十五 .  Future

```java
> future 可以用于异步获取多线程任务结果
表示异步任务，是还没有完成的任务给出的未来结果
Callable 用于产生结果，Future 用于获取结果
    
// 使用 future 会有以下效果：
> 1  启动多线程任务
> 2  处理其他事情
> 3  收集多线程任务结果


// Future 对应的方法
> cancel(boolean)
> get ： 获取结果
> get(long,TimeUtil)
> isCancelled()
> isDone() ：判断是否有结果

// 推荐先判断 ，再获取

// 分析 ： 
流程类似于叫好等餐 ， 等餐是花费时间的过程，但是不妨碍我们叫号
Future 接口的作用就是先生成一个 Future 对象 ，将具体的运行放入future 对象中 ，最终通过future 对象的 get 方法来获取最终的结果
    
    
```

### 15 . 1  Future Task

```
FutureTask 表示一个可以取消的异步运算
> 它有启动和取消运算、查询运算是否完成和取回运算结果等方法。
> 只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞
```



##  十六  . Fork / join

### 16 . 1 简述

```
> 什么是 Fork / Join 
	: 该框架是一个工具 , 通过分而治之的方式尝试将所有可用的处理器内核使用起来帮助加速并行处理
	- fork : 递归地将任务分解为较小的独立子任务 , 直到它们足够简单以便异步执行
	- join : 将所有子任务的结果递归的连接成单个结果
	
> 专属线程池 : 
	- ForkJoinPool  : 用于管理 ForkJoinWorkerThread 类型的工作线程
	
> 实现了 ExecutorService接口 的多线程处理器
> 把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率

```



## 十七 . 多线程算法

### 15 . 1 算法简述

```
> 线程调度算法
	- 分时调度模型
		: 让所有的线程轮流获得CPU的使用权 ,平均分配占用的时间
	- 抢占式算法 (Java 虚拟机)
		: 优先让运行池中优先级高的线程占用 CPU
		: 优先级相同时随机选择

> 线程优先级
	: 线程优先级是 int 类型的 1-10
	: 线程优先级虽然定义后但是不一定优先级高的先执行
	: 线程的优先级调度通常会被委托给操作系统
```

### 15 . 2 线程池的实现算法

```

```



## 十八 .  零散知识点

### # 并发和并行

```
// 并发（Concurrency）和并行（Parallellism）是：
解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。
解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。
```



### # 线程的基本概念

```java
// 进程 
	进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。
	
// 线程
	进程中的一个执行流程，一个进程中可以运行多个线程
	
// Java 中的线程
	1、java.lang.Thread类的一个实例；
	2、线程的执行。
	
// 一旦创建一个新的线程，就产生一个新的调用栈。

// 线程总体分两类：用户线程和守候线程。是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的

// 创建线程的三种方式
• 方式一，继承 Thread 类创建线程类。
	- 编写简单 ,可以直接通过this访问当前线程
	- 多继承限制了能力的发展
• 方式二，通过 Runnable 接口创建线程类。
• 方式三，通过 Callable 和 Future 创建线程。
	- 可以使用线程池 , 设计清楚
	
// 状态的改变
	: 当 2 个人去约会的情况下 ,当不互相沟通的情况下 ,我们是不能了解到对方的情况 ,对方的情况就是状态 ,当我们打一次电话就是同步了一次状态 ,当挂掉后 , 双方继续同时做事 ,此时状态又不可见
	
// 复合操作
	: 检查在运行(例如惰性初始化)
	: 读 - 改 -写 : 自增
```

### # 线程的创建

```
方式一，继承 Thread 类创建线程类。
方式二，通过 Runnable 接口创建线程类。
方式三，通过 Callable 和 Future 创建线程。
```

### # 线程的基本使用

```
> 扩展java.lang.Thread类 , 直接 new
> 实现java.lang.Runnable接口 , 调用 Thread 的 构造方法

> 启动教程 : 调用 start()
在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。
在调用start()方法之后：发生了一系列复杂的事情
	- 启动新的执行线程（具有新的调用栈）
	- 该线程从新状态转移到可运行状态
	- 当该线程获得机会执行时，其目标run()方法将运行。
	
> run 和 start 的区别
	- 调用start 的时候 , 会创建新的线程 , 并且执行run 方法
	- 调用run 方法仅仅是简单的调用
```



### # 线程的状态及转换

```
> 线程有五个状态
	- 新建 new
	- 可运行 runnable
	- 运行 running
	- 阻塞 block
	- 死亡 dead
	
> running
	running -> lockpool(线程等待池) : 在里面等待锁
		1 > synchronized
	running -> release lock or monitor (等待队列)
    	1 > o.wait()
    running -> 阻塞状态
    	1 > 等待用户输入
    	2 > Thread.sleep
            3 > t2.join()
    running -> Runnable
		1 > 时间片用完
         2 > Thread.yield()
	running -> dead
		1 > run() - main() 方法结束
		2 > 异常推出
         
> Runnable : 可运行状态
	Runnable -> running
		1 > 获取到 CPU 时间片
    	
> 阻塞状态
	柱塞状态 -> runnable(可运行状态)
		1 > 用户输入完成
		2 > sleep 时间结束
		3 > t2 线程结束
		
> release lock or monitor (等待队列)
	等待队列 -> 线程锁池
		1 > o.notify()
		2 > o.notifyAll()

> lock pool (锁池)
	lock pool -> Runnable
		1 > 拿到锁后放入可运行状态
		
	• 还没起床：sleeping 。
	• 起床收拾好了，随时可以坐地铁出发：Runnable 。
	• 等地铁来：Waiting 。
	• 地铁来了，但要排队上地铁：I/O 阻塞 。
	• 上了地铁，发现暂时没座位：synchronized 阻塞。
	• 地铁上找到座位：Running 。
	• 到达目的地：Dead 。		
```

<img src="C:\Users\10169\OneDrive\图片\工作\学习\多线程\状态的转换.jpg.png" style="zoom:150%;" />

<img src="C:\Users\10169\OneDrive\图片\工作\学习\多线程\xianc.png" style="zoom:200%;" />


### # 什么是锁机制

```
// 锁的类型
	• 自旋锁
		○ 适应自旋锁
	• 锁消除
	• 锁粗化
	• 锁的升级
		○ 重量级锁
		○ 轻量级锁
		○ 偏向锁
    

> 内部锁 : 
	synchronized : 锁对象的引用 , 锁保护的代码块
	每个Java 对象都可以隐式地扮演一个用于同步的锁的角色 ,这些内置的锁被称为 内部锁 或 监视器锁 .
	
	
```

### # 实现Runnable接口和Callable接口的区别**

```
Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。
 
工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。
```



### # 常见的线程安全和线程不安全

```
Servlet 不是线程安全的，Servlet 是单实例多线程的，
Struts2 的 Action 是多实例多线程的，是线程安全的
SpringMVC 不是线程安全
饿汉式单例模式的写法：线程安全
懒汉式单例模式的写法：非线程安全
双检锁单例模式的写法：线程安全
```

### # 写时复制技术

```
写时复制就是将共享访问的对象变为只读的，写的时候，再使用锁，保证只有一个线程写，写的线程不是直接修改原对象，而是新创建一个对象，对该对象修改完毕后，再原子性地修改共享访问的变量，让它指向新的对象。

这个可以通过容器类 : CopyOnWriteArrayList和CopyOnWriteArraySet 来体现

```

### # 线程的 CPU 时间片

```
- 当前运行线程主动放弃CPU，JVM暂时放弃CPU操作（基于时间片轮转调度的JVM操作系统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权），例如调用yield()方法。
- 当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O上。
- 当前运行线程结束，即运行完run()方法里面的任务。

Java的线程的调度机制都由JVM实现，假如有若干条线程，你想让某些线程拥有更长的执行时间，或某些线程分配少点执行时间，这时就涉及“线程优先级”，Java把线程优先级分成10个级别，线程被创建时如果没有明确声明则使用默认优先级，JVM将根据每个线程的优先级分配执行时间的概率。

有三个常量Thread.MIN_PRIORITY、Thread.NORM_PRIORITY、Thread.MAX_PRIORITY分别表示最小优先级值（1）、默认优先级值（5）、最大优先级值（10）。

由于JVM的实现以宿主操作系统为基础，所以Java优先级值与各种不同操作系统的原生线程优先级必然存在某种映射关系，这样才足以封装所有操作系统的优先级提供统一优先级语义。例如1-10优先级值在linux可能要与0-99优先级值进行映射，而windows系统则有7个优先级要映射。
线程的调度策略决定上层多线程运行机制，JVM的线程调度器实现了抢占式调度，每条线程执行的时间由它分配管理，它将按照线程优先级的建议对线程执行的时间进行分配，优先级越高，可能得到CPU的时间则越长。
```

### # **执行execute()方法和submit()方法的区别**

```
1)execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
2)submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

```

### # 定时组件

```
Future + Callable
	?- 可以实现有效的回调
java.util包中的Timer和TimerTask
	?- 一个Timer对象背后只有一个Timer线程
Java并发包中的ScheduledExecutorService
```

### # 线程的名称

```
- 线程总是有名称 ,如果没有定义 , 则线程名称由 Java 虚拟机指定
- 任何线程的名称都可以设置和获取
```

### #  守护线程

```
- 线程分为守护线程和用户线程
- 任何线程都可以设置为守护线程(setDeamor(Boolean on))和用户线程
  - 守护线程的设置必须再 start 方法之前
- 守护线程是 JVM 自动创建的线程 ,用户线程是程序创建的线程
- 普通线程和守护线程的区别是普通线程全部关闭后 , JVM 才会关闭 ,从而关闭守护线程
```

### #  线程饥饿

```
- 一个或者多个线程因为种种原因无法获取所需要的资源,导致一直无法执行的状态
- 高优先级线程占用了所有的 CPU 时间
- 其他线程持续的占用同步块,导致某个线程一直等待同步块
```

### #  线程停和线程启的几种方法和区别

```
- wait : 使一个线程处于等待的状态 ,并且释放锁
- sleep : 使一个正在运行的线程处于睡眠状态 , 此方法为一个静态方法
- notify : 唤醒一个等待的线程 , 调用此方法时并不能确定会唤醒哪一个线程, 且与优先级无关 这个唤醒操作会由 JVM 决定
- notifyAll : 唤醒所有等待的线程 , 由所有线程去竞争锁 , 获取了锁的线程会进入就绪状态
```

### # 为什么 wait / notify / notifyall 方法不在Thread 类里面 ? 

```
Java 提供的锁是对象级而不是线程级的 , 每一个对象都有一个锁
```

### # sleep、join、yield

```
- sleep : sleep 是系统级 , 精准的让出 CPU 资源 , 让其他的线程有机会执行(使低优先级的线程有机会执行) , 但是这个状态不会释放锁
- yield : 该方法是使线程重新回到可执行的状态 ,但是因为是放入线程池里面 , 所以随时都可能进入到运行状态
```



----------------------------------------

> 
>
> - 

----------------------------------------

> wait 和 notify 需要放到同步块里面 , wait 和 notify 之间产生竞态条件	

----------------------------------------

> 
> - 

----------------------------------------

> sleep(0)
>
> - 主要占用是让出资源 ,使其他的对象有机会获取线程锁

----------------------------------------

> 常见的线程安全类型
>  	- 指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成
> - 线程安全
> 	: struts2 -- 多实例多线程
> 	: 饿汉式单例模式
> 	: 双检锁单例模式
> - 线程不安全
> 	: servlet -- 单实例多线程的 , 不能保证共享变量的线程安全性
> 	: springMVC -- 基于servlet 
> 	: 懒汉式单例模式 (不加同步锁时)

----------------------------------------

> 多线程的同步和互斥
> - 线程同步 : 线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息
> - 用户模式 : 只用用户态完成操作
> 	: 原子操作 , 临界区
> - 内核模式 : 使用系统内核对象的单一性来进行同步 ,需要切换内核态与用户态
> 	: 事件 , 信号量 ,互斥量
> - 线程互斥
>   	: 指对于共享的进程系统资源，在各单个线程访问时的排它性
>     	: 线程互斥可以理解为特殊的线程同步

----------------------------------------

> volatile 
> - 保证内存可见性和禁止指令重排
> - volatile 用于多线程环境下的单次操作(单次读或者单次写)



## 十九 . 优化和实践

```
• 1、给线程命名。
这样可以方便找 bug 或追踪。OrderProcessor、QuoteProcessor、TradeProcessor 这种名字比 Thread-1、Thread-2、Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
• 2、最小化同步范围。
锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
• 3、优先使用 volatile ，而不是 synchronized 。
• 4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。
首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。
其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
• 5、优先使用并发容器，而非同步容器。
这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。
6、考虑使用线程池。
```



## 参考文档



